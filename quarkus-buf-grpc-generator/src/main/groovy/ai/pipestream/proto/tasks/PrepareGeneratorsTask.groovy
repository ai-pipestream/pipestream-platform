package ai.pipestream.proto.tasks

import ai.pipestream.proto.BufPlugin
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.Internal
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction

/**
 * Prepares code generator plugins and creates buf.gen.yaml configuration.
 *
 * This task:
 * 1. Resolves the Quarkus gRPC protoc plugin JAR from Maven
 * 2. Creates a shell wrapper script (protoc-gen-mutiny) that invokes the Java generator
 * 3. Generates a buf.gen.yaml with absolute paths for all plugins
 * 4. Includes any extra plugins configured by the user
 */
abstract class PrepareGeneratorsTask extends DefaultTask {

    /**
     * Quarkus gRPC version for resolving the Mutiny generator.
     */
    @Input
    abstract Property<String> getQuarkusGrpcVersion()

    /**
     * Whether to generate Quarkus Mutiny stubs.
     */
    @Input
    abstract Property<Boolean> getGenerateMutiny()

    /**
     * Whether to generate standard gRPC stubs.
     */
    @Input
    abstract Property<Boolean> getGenerateGrpc()

    /**
     * Output directory for generated Java sources (used in buf.gen.yaml).
     * Marked @Internal because DirectoryProperty can't be @Input directly.
     */
    @Internal
    abstract DirectoryProperty getOutputDir()

    /**
     * The output directory path as a string input for up-to-date checking.
     * If the output path changes, the task will re-run.
     */
    @Input
    String getOutputDirPath() {
        return getOutputDir().get().asFile.absolutePath
    }

    /**
     * Directory for protoc plugin scripts.
     */
    @OutputDirectory
    abstract DirectoryProperty getPluginDir()

    /**
     * The generated buf.gen.yaml file.
     */
    @OutputFile
    abstract RegularFileProperty getBufGenYaml()

    /**
     * Extra buf plugins to include in generation.
     * Marked @Internal because the container itself isn't serializable.
     */
    @Internal
    Iterable<BufPlugin> extraPlugins

    @TaskAction
    void prepare() {
        def pluginDir = getPluginDir().get().asFile
        def bufGenYaml = getBufGenYaml().get().asFile
        def outputDir = getOutputDir().get().asFile.absolutePath
        def generateMutiny = getGenerateMutiny().get()
        def generateGrpc = getGenerateGrpc().get()

        pluginDir.mkdirs()

        String mutinyPluginPath = null
        if (generateMutiny) {
            mutinyPluginPath = this.prepareMutinyGenerator(pluginDir)
        }

        this.generateBufGenYaml(bufGenYaml, outputDir, generateGrpc, mutinyPluginPath, extraPlugins)

        logger.lifecycle("Generated buf.gen.yaml at: ${bufGenYaml}")
    }

    /**
     * Resolves the Quarkus gRPC protoc plugin and creates a wrapper script.
     * Returns the absolute path to the wrapper script.
     */
    private String prepareMutinyGenerator(File pluginDir) {
        def version = getQuarkusGrpcVersion().get()
        logger.lifecycle("Resolving quarkus-grpc-protoc-plugin:${version}")

        // Create a detached configuration to resolve the plugin JAR and its dependencies
        def config = project.configurations.detachedConfiguration(
            project.dependencies.create("io.quarkus:quarkus-grpc-protoc-plugin:${version}")
        )

        def files = config.resolve()
        if (files.isEmpty()) {
            throw new GradleException("Failed to resolve quarkus-grpc-protoc-plugin:${version}")
        }

        // Build classpath string
        def classpath = files.collect { it.absolutePath }.join(File.pathSeparator)
        logger.debug("Mutiny generator classpath: ${classpath}")

        // Create wrapper script
        def scriptFile = new File(pluginDir, "protoc-gen-mutiny")
        scriptFile.text = """\
#!/bin/sh
# Generated by pipestream-proto-toolchain
# Wrapper for Quarkus Mutiny gRPC generator
set -e
exec java -cp "${classpath}" io.quarkus.grpc.protoc.plugin.MutinyGrpcGenerator "\$@"
"""
        scriptFile.setExecutable(true)

        // TODO: Add Windows .bat support if needed
        // def batFile = new File(pluginDir, "protoc-gen-mutiny.bat")
        // batFile.text = "@echo off\r\njava -cp \"${classpath.replace(':', ';')}\" ..."

        logger.lifecycle("Created Mutiny generator wrapper: ${scriptFile}")
        return scriptFile.absolutePath
    }

    /**
     * Generates the buf.gen.yaml configuration file with absolute paths.
     */
    protected void generateBufGenYaml(File yamlFile, String outputDir, boolean generateGrpc,
                                      String mutinyPluginPath, Iterable<BufPlugin> extraPlugins) {
        def yaml = new StringBuilder()
        yaml.append("# Generated by pipestream-proto-toolchain\n")
        yaml.append("# DO NOT EDIT - regenerate with ./gradlew prepareGenerators\n")
        yaml.append("version: v1\n")
        yaml.append("plugins:\n")

        // Standard Java POJOs (always included)
        yaml.append("  - plugin: buf.build/protocolbuffers/java\n")
        yaml.append("    out: ${outputDir}\n")

        // Standard gRPC stubs
        if (generateGrpc) {
            yaml.append("  - plugin: buf.build/grpc/java\n")
            yaml.append("    out: ${outputDir}\n")
        }

        // Quarkus Mutiny stubs
        if (mutinyPluginPath) {
            yaml.append("  - name: mutiny\n")
            yaml.append("    path: ${mutinyPluginPath}\n")
            yaml.append("    out: ${outputDir}\n")
            yaml.append("    opt:\n")
            yaml.append("      - quarkus.generate-code.grpc.scan-for-imports=none\n")
        }

        // Extra plugins configured by user
        if (extraPlugins) {
            extraPlugins.each { plugin ->
                yaml.append("  - plugin: ${plugin.plugin.get()}\n")

                // Resolve output path - make it absolute if relative
                def pluginOut = plugin.out.get()
                if (!pluginOut.startsWith('/')) {
                    pluginOut = project.file(pluginOut).absolutePath
                }
                yaml.append("    out: ${pluginOut}\n")

                // Add options if present
                def opts = plugin.opt.getOrNull()
                if (opts && !opts.isEmpty()) {
                    yaml.append("    opt:\n")
                    opts.each { opt ->
                        yaml.append("      - ${opt}\n")
                    }
                }
            }
        }

        yamlFile.text = yaml.toString()
    }
}
